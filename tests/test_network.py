"""
Tests for container-network.bbclass Quadlet network generation.

Covers validation (do_validate_network) and generation (do_generate_network)
of Podman Quadlet .network unit files.
"""

import os

import pytest

from conftest import (
    BBFatalError,
    MockBB,
    MockDataStore,
    load_bbclass,
    parse_quadlet,
)

BBCLASS = os.path.join(
    os.path.dirname(os.path.dirname(__file__)), "classes", "container-network.bbclass"
)


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------

@pytest.fixture
def bb():
    return MockBB()


@pytest.fixture
def d(tmp_path):
    ds = MockDataStore()
    ds.setVar("WORKDIR", str(tmp_path))
    return ds


@pytest.fixture
def ns(bb):
    """Load the bbclass and return its namespace."""
    return load_bbclass(BBCLASS, mock_bb=bb)


def _generate(ns, d, bb):
    """Convenience wrapper: run do_generate_network and return the parsed file."""
    ns["do_generate_network"](d, bb)
    name = d.getVar("NETWORK_NAME")
    enabled = d.getVar("NETWORK_ENABLED")
    if enabled == "0":
        path = os.path.join(d.getVar("WORKDIR"), "quadlets-available", name + ".network")
    else:
        path = os.path.join(d.getVar("WORKDIR"), "quadlets", name + ".network")
    assert os.path.isfile(path), f"Expected network file at {path}"
    with open(path) as f:
        content = f.read()
    return content, parse_quadlet(content)


# ---------------------------------------------------------------------------
# 1. Basic network (minimal config â€“ NETWORK_NAME only)
# ---------------------------------------------------------------------------

class TestBasicNetwork:
    def test_minimal_generates_all_sections(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        content, parsed = _generate(ns, d, bb)
        assert "Unit" in parsed
        assert "Network" in parsed
        assert "Install" in parsed

    def test_minimal_unit_description(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Unit"]["Description"] == "mynet network"

    def test_minimal_network_name(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["NetworkName"] == "mynet"

    def test_minimal_install_wanted_by(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Install"]["WantedBy"] == "multi-user.target"

    def test_minimal_no_driver(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        _, parsed = _generate(ns, d, bb)
        assert "Driver" not in parsed["Network"]

    def test_file_written_to_quadlets_dir(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        ns["do_generate_network"](d, bb)
        expected = os.path.join(d.getVar("WORKDIR"), "quadlets", "mynet.network")
        assert os.path.isfile(expected)

    def test_auto_generated_comment(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        content, _ = _generate(ns, d, bb)
        assert "Auto-generated by meta-container-deploy" in content

    def test_bb_note_logged(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        ns["do_generate_network"](d, bb)
        assert any("Generated Quadlet network file" in n for n in bb.notes)


# ---------------------------------------------------------------------------
# 2. Driver
# ---------------------------------------------------------------------------

class TestDriver:
    @pytest.mark.parametrize("driver", ["bridge", "macvlan", "ipvlan"])
    def test_driver_written(self, ns, d, bb, driver):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_DRIVER", driver)
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Driver"] == driver

    def test_empty_driver_omitted(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_DRIVER", "")
        _, parsed = _generate(ns, d, bb)
        assert "Driver" not in parsed["Network"]


# ---------------------------------------------------------------------------
# 3. Subnet + Gateway
# ---------------------------------------------------------------------------

class TestSubnetGateway:
    def test_subnet(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_SUBNET", "10.89.0.0/24")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Subnet"] == "10.89.0.0/24"

    def test_gateway(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_GATEWAY", "10.89.0.1")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Gateway"] == "10.89.0.1"

    def test_subnet_and_gateway_together(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_SUBNET", "172.20.0.0/16")
        d.setVar("NETWORK_GATEWAY", "172.20.0.1")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Subnet"] == "172.20.0.0/16"
        assert parsed["Network"]["Gateway"] == "172.20.0.1"

    def test_no_subnet_no_gateway(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        _, parsed = _generate(ns, d, bb)
        assert "Subnet" not in parsed["Network"]
        assert "Gateway" not in parsed["Network"]


# ---------------------------------------------------------------------------
# 4. IP Range
# ---------------------------------------------------------------------------

class TestIPRange:
    def test_ip_range_set(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_IP_RANGE", "10.89.0.128/25")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["IPRange"] == "10.89.0.128/25"

    def test_ip_range_omitted_when_empty(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        _, parsed = _generate(ns, d, bb)
        assert "IPRange" not in parsed["Network"]


# ---------------------------------------------------------------------------
# 5. IPv6
# ---------------------------------------------------------------------------

class TestIPv6:
    def test_ipv6_enabled(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_IPV6", "1")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["IPv6"] == "true"

    def test_ipv6_not_set(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        _, parsed = _generate(ns, d, bb)
        assert "IPv6" not in parsed["Network"]

    def test_ipv6_explicit_zero(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_IPV6", "0")
        _, parsed = _generate(ns, d, bb)
        assert "IPv6" not in parsed["Network"]


# ---------------------------------------------------------------------------
# 6. Internal
# ---------------------------------------------------------------------------

class TestInternal:
    def test_internal_enabled(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_INTERNAL", "1")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Internal"] == "true"

    def test_internal_not_set(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        _, parsed = _generate(ns, d, bb)
        assert "Internal" not in parsed["Network"]

    def test_internal_explicit_zero(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_INTERNAL", "0")
        _, parsed = _generate(ns, d, bb)
        assert "Internal" not in parsed["Network"]


# ---------------------------------------------------------------------------
# 7. DNS servers
# ---------------------------------------------------------------------------

class TestDNS:
    def test_single_dns(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_DNS", "8.8.8.8")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["DNS"] == "8.8.8.8"

    def test_multiple_dns(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_DNS", "8.8.8.8 1.1.1.1 9.9.9.9")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["DNS"] == ["8.8.8.8", "1.1.1.1", "9.9.9.9"]

    def test_dns_omitted_when_empty(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        _, parsed = _generate(ns, d, bb)
        assert "DNS" not in parsed["Network"]


# ---------------------------------------------------------------------------
# 8. Labels
# ---------------------------------------------------------------------------

class TestLabels:
    def test_single_label(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_LABELS", "app=frontend")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Label"] == "app=frontend"

    def test_multiple_labels(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_LABELS", "app=frontend env=prod tier=web")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Label"] == [
            "app=frontend",
            "env=prod",
            "tier=web",
        ]

    def test_labels_without_equals_skipped(self, ns, d, bb):
        """Labels without '=' are silently ignored per the bbclass logic."""
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_LABELS", "badlabel app=frontend noeq")
        _, parsed = _generate(ns, d, bb)
        # Only the valid label should appear
        assert parsed["Network"]["Label"] == "app=frontend"

    def test_labels_omitted_when_empty(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        _, parsed = _generate(ns, d, bb)
        assert "Label" not in parsed["Network"]


# ---------------------------------------------------------------------------
# 9. Options
# ---------------------------------------------------------------------------

class TestOptions:
    def test_single_option(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_OPTIONS", "mtu=9000")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Options"] == "mtu=9000"

    def test_multiple_options(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_OPTIONS", "mtu=9000 vlan=100")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Options"] == ["mtu=9000", "vlan=100"]

    def test_options_without_equals_skipped(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_OPTIONS", "badopt mtu=9000")
        _, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["Options"] == "mtu=9000"

    def test_options_omitted_when_empty(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        _, parsed = _generate(ns, d, bb)
        assert "Options" not in parsed["Network"]


# ---------------------------------------------------------------------------
# 10. Disabled network (NETWORK_ENABLED = "0")
# ---------------------------------------------------------------------------

class TestDisabledNetwork:
    def test_disabled_writes_to_available_dir(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        d.setVar("NETWORK_ENABLED", "0")
        ns["do_generate_network"](d, bb)
        expected = os.path.join(
            d.getVar("WORKDIR"), "quadlets-available", "mynet.network"
        )
        assert os.path.isfile(expected)

    def test_disabled_not_in_active_dir(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        d.setVar("NETWORK_ENABLED", "0")
        ns["do_generate_network"](d, bb)
        active = os.path.join(d.getVar("WORKDIR"), "quadlets", "mynet.network")
        assert not os.path.exists(active)

    def test_disabled_content_still_valid(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        d.setVar("NETWORK_ENABLED", "0")
        content, parsed = _generate(ns, d, bb)
        assert parsed["Network"]["NetworkName"] == "mynet"
        assert parsed["Install"]["WantedBy"] == "multi-user.target"

    def test_enabled_writes_to_active_dir(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "mynet")
        d.setVar("NETWORK_ENABLED", "1")
        ns["do_generate_network"](d, bb)
        expected = os.path.join(d.getVar("WORKDIR"), "quadlets", "mynet.network")
        assert os.path.isfile(expected)


# ---------------------------------------------------------------------------
# 11. Full config (all options set)
# ---------------------------------------------------------------------------

class TestFullConfig:
    def test_all_options_present(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "fullnet")
        d.setVar("NETWORK_DRIVER", "bridge")
        d.setVar("NETWORK_SUBNET", "10.50.0.0/24")
        d.setVar("NETWORK_GATEWAY", "10.50.0.1")
        d.setVar("NETWORK_IP_RANGE", "10.50.0.128/25")
        d.setVar("NETWORK_IPV6", "1")
        d.setVar("NETWORK_INTERNAL", "1")
        d.setVar("NETWORK_DNS", "8.8.8.8 1.1.1.1")
        d.setVar("NETWORK_LABELS", "env=prod team=ops")
        d.setVar("NETWORK_OPTIONS", "mtu=9000 vlan=42")
        d.setVar("NETWORK_ENABLED", "1")

        content, parsed = _generate(ns, d, bb)

        # [Unit]
        assert parsed["Unit"]["Description"] == "fullnet network"

        # [Network]
        net = parsed["Network"]
        assert net["NetworkName"] == "fullnet"
        assert net["Driver"] == "bridge"
        assert net["Subnet"] == "10.50.0.0/24"
        assert net["Gateway"] == "10.50.0.1"
        assert net["IPRange"] == "10.50.0.128/25"
        assert net["IPv6"] == "true"
        assert net["Internal"] == "true"
        assert net["DNS"] == ["8.8.8.8", "1.1.1.1"]
        assert net["Label"] == ["env=prod", "team=ops"]
        assert net["Options"] == ["mtu=9000", "vlan=42"]

        # [Install]
        assert parsed["Install"]["WantedBy"] == "multi-user.target"

    def test_full_config_file_in_active_quadlets(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "fullnet")
        d.setVar("NETWORK_DRIVER", "bridge")
        d.setVar("NETWORK_SUBNET", "10.50.0.0/24")
        d.setVar("NETWORK_GATEWAY", "10.50.0.1")
        d.setVar("NETWORK_ENABLED", "1")
        ns["do_generate_network"](d, bb)
        path = os.path.join(d.getVar("WORKDIR"), "quadlets", "fullnet.network")
        assert os.path.isfile(path)

    def test_full_config_content_ordering(self, ns, d, bb):
        """Verify that sections appear in the expected order."""
        d.setVar("NETWORK_NAME", "ordernet")
        d.setVar("NETWORK_DRIVER", "bridge")
        d.setVar("NETWORK_SUBNET", "10.0.0.0/8")

        content, _ = _generate(ns, d, bb)

        unit_pos = content.index("[Unit]")
        network_pos = content.index("[Network]")
        install_pos = content.index("[Install]")
        assert unit_pos < network_pos < install_pos


# ---------------------------------------------------------------------------
# 12. Validation: missing NETWORK_NAME
# ---------------------------------------------------------------------------

class TestValidationMissingName:
    def test_missing_name_raises(self, ns, d, bb):
        # NETWORK_NAME is not set (getVar returns None)
        with pytest.raises(BBFatalError, match="NETWORK_NAME must be set"):
            ns["do_validate_network"](d, bb)

    def test_empty_name_raises(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "")
        with pytest.raises(BBFatalError, match="NETWORK_NAME must be set"):
            ns["do_validate_network"](d, bb)

    def test_valid_name_passes(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "goodnet")
        # Should not raise
        ns["do_validate_network"](d, bb)


# ---------------------------------------------------------------------------
# 13. Validation: invalid driver
# ---------------------------------------------------------------------------

class TestValidationInvalidDriver:
    def test_invalid_driver_raises(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_DRIVER", "invalid")
        with pytest.raises(BBFatalError, match="NETWORK_DRIVER must be one of"):
            ns["do_validate_network"](d, bb)

    def test_invalid_driver_error_includes_value(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_DRIVER", "overlay")
        with pytest.raises(BBFatalError, match="overlay"):
            ns["do_validate_network"](d, bb)

    @pytest.mark.parametrize("driver", ["bridge", "macvlan", "ipvlan"])
    def test_valid_drivers_pass(self, ns, d, bb, driver):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_DRIVER", driver)
        ns["do_validate_network"](d, bb)

    def test_empty_driver_passes_validation(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        d.setVar("NETWORK_DRIVER", "")
        ns["do_validate_network"](d, bb)

    def test_no_driver_passes_validation(self, ns, d, bb):
        d.setVar("NETWORK_NAME", "net1")
        # NETWORK_DRIVER not set at all
        ns["do_validate_network"](d, bb)
