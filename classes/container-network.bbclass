# SPDX-License-Identifier: MIT
#
# container-network.bbclass - Generate Podman Quadlet network units
#
# This class generates Podman Quadlet .network files for creating named
# Podman networks. When containers or pods reference a named network via
# Network=<name>, Quadlet automatically resolves the corresponding
# .network file and handles dependency ordering.
#
# Usage:
#   inherit container-network
#
#   NETWORK_NAME = "appnet"
#   NETWORK_DRIVER = "bridge"
#   NETWORK_SUBNET = "10.89.0.0/24"
#   NETWORK_GATEWAY = "10.89.0.1"
#
# Optional variables:
#   NETWORK_DRIVER - Network driver: bridge (default), macvlan, ipvlan
#   NETWORK_SUBNET - Subnet in CIDR notation (e.g., "10.89.0.0/24")
#   NETWORK_GATEWAY - Gateway address for the subnet
#   NETWORK_IP_RANGE - Allocatable IP range within the subnet (CIDR)
#   NETWORK_IPV6 - Set to "1" to enable IPv6 support
#   NETWORK_INTERNAL - Set to "1" to disable external connectivity
#   NETWORK_DNS - Space-separated DNS server addresses
#   NETWORK_LABELS - Space-separated key=value label pairs
#   NETWORK_OPTIONS - Space-separated key=value driver-specific options (e.g., mtu=9000)
#   NETWORK_ENABLED - Set to "0" to disable auto-start (default: 1). Disabled networks
#                     have their Quadlet file installed to /etc/containers/systemd-available/
#                     instead of the active /etc/containers/systemd/ directory.
#                     To enable at runtime:
#                       cp /etc/containers/systemd-available/<name>.network /etc/containers/systemd/
#                       systemctl daemon-reload
#
# Copyright (c) 2026 Marco Pennelli <marco.pennelli@technosec.net>
# SPDX-License-Identifier: MIT

RDEPENDS:${PN} += "podman"

# Required variables
NETWORK_NAME ?= "${PN}"

# Optional configuration variables
NETWORK_DRIVER ?= ""
NETWORK_SUBNET ?= ""
NETWORK_GATEWAY ?= ""
NETWORK_IP_RANGE ?= ""
NETWORK_IPV6 ?= ""
NETWORK_INTERNAL ?= ""
NETWORK_DNS ?= ""
NETWORK_LABELS ?= ""
NETWORK_OPTIONS ?= ""
NETWORK_ENABLED ?= "1"

# Quadlet installation directory
QUADLET_DIR = "${sysconfdir}/containers/systemd"

# Validate required variables
python do_validate_network() {
    network_name = d.getVar('NETWORK_NAME')

    if not network_name:
        bb.fatal("NETWORK_NAME must be set when inheriting container-network.bbclass")

    # Validate driver if specified
    driver = d.getVar('NETWORK_DRIVER')
    if driver and driver not in ('bridge', 'macvlan', 'ipvlan'):
        bb.fatal("NETWORK_DRIVER must be one of: bridge, macvlan, ipvlan (got '%s')" % driver)
}
addtask validate_network before do_compile

# Generate Quadlet .network file during compile
python do_generate_network() {
    import os

    network_name = d.getVar('NETWORK_NAME')

    # Build Quadlet network file content
    lines = []

    # [Unit] section
    lines.append("# Podman Quadlet network file for " + network_name)
    lines.append("# Auto-generated by meta-container-deploy")
    lines.append("")
    lines.append("[Unit]")
    lines.append("Description=" + network_name + " network")
    lines.append("")

    # [Network] section
    lines.append("[Network]")
    lines.append("NetworkName=" + network_name)

    # Driver
    driver = d.getVar('NETWORK_DRIVER')
    if driver:
        lines.append("Driver=" + driver)

    # Subnet
    subnet = d.getVar('NETWORK_SUBNET')
    if subnet:
        lines.append("Subnet=" + subnet)

    # Gateway
    gateway = d.getVar('NETWORK_GATEWAY')
    if gateway:
        lines.append("Gateway=" + gateway)

    # IP range
    ip_range = d.getVar('NETWORK_IP_RANGE')
    if ip_range:
        lines.append("IPRange=" + ip_range)

    # IPv6
    ipv6 = d.getVar('NETWORK_IPV6')
    if ipv6 == '1':
        lines.append("IPv6=true")

    # Internal (no external connectivity)
    internal = d.getVar('NETWORK_INTERNAL')
    if internal == '1':
        lines.append("Internal=true")

    # DNS servers
    dns = d.getVar('NETWORK_DNS')
    if dns:
        for server in dns.split():
            lines.append("DNS=" + server)

    # Labels
    labels = d.getVar('NETWORK_LABELS')
    if labels:
        for label in labels.split():
            if '=' in label:
                lines.append("Label=" + label)

    # Driver-specific options
    options = d.getVar('NETWORK_OPTIONS')
    if options:
        for opt in options.split():
            if '=' in opt:
                lines.append("Options=" + opt)

    lines.append("")

    # [Install] section
    lines.append("[Install]")
    lines.append("WantedBy=multi-user.target")

    # Write the Quadlet network file to active or available directory based on enabled state
    workdir = d.getVar('WORKDIR')
    enabled = d.getVar('NETWORK_ENABLED')
    if enabled == '0':
        quadlet_dir = os.path.join(workdir, 'quadlets-available')
    else:
        quadlet_dir = os.path.join(workdir, 'quadlets')
    os.makedirs(quadlet_dir, exist_ok=True)
    network_file = os.path.join(quadlet_dir, network_name + ".network")

    with open(network_file, 'w') as f:
        f.write('\n'.join(lines))
        f.write('\n')

    bb.note("Generated Quadlet network file: " + network_file)
}

addtask do_generate_network after do_configure before do_compile

# Install Quadlet network file (active or available based on enabled state)
do_install:append() {
    NETWORK_NAME="${NETWORK_NAME}"

    if [ -f "${WORKDIR}/quadlets/${NETWORK_NAME}.network" ]; then
        install -d ${D}${QUADLET_DIR}
        install -m 0644 ${WORKDIR}/quadlets/${NETWORK_NAME}.network \
            ${D}${QUADLET_DIR}/
    elif [ -f "${WORKDIR}/quadlets-available/${NETWORK_NAME}.network" ]; then
        install -d ${D}${sysconfdir}/containers/systemd-available
        install -m 0644 ${WORKDIR}/quadlets-available/${NETWORK_NAME}.network \
            ${D}${sysconfdir}/containers/systemd-available/
    fi
}

# Package files - use :append to allow combining with other bbclasses
FILES:${PN}:append = " ${QUADLET_DIR}/${NETWORK_NAME}.network ${sysconfdir}/containers/systemd-available/${NETWORK_NAME}.network"
